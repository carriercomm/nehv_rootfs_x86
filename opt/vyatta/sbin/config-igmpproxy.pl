#!/usr/bin/perl
#
# Module: config-igmpproxy.pl
# 
# **** License ****
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# This code was originally developed by Ubiquiti, Inc.
# Portions created by Ubiquiti are Copyright (C) 2011 Ubiquiti, Inc.
# All Rights Reserved.
# 
# Author: Stig Thormodsrud
# Date: July 2011
# Description: Script to configure igmpproxy
# 
# **** End License ****
#

use Getopt::Long;
use POSIX;
use File::Basename;
use File::Compare;
use NetAddr::IP;

use lib '/opt/vyatta/share/perl5';
use Vyatta::Config;
use Vyatta::Interface;

use warnings;
use strict;

my $daemon   = '/sbin/igmpproxy';
my $pidfile  = '/var/run/igmpproxy.pid';
my $conffile = '/etc/igmpproxy.conf';

sub is_running {
    my ($pid_file) = @_;

    if (defined $pid_file and -f $pid_file) {
	my $pid = `cat $pid_file`;
	chomp $pid;
	my $ps = `ps -p $pid -o comm=`;

	if (defined($ps) && $ps ne "") {
	    return 1;
	} 
    }
    return 0;
}

sub is_disabled {
    my $config = new Vyatta::Config;
    $config->setLevel('protocols igmp-proxy');
    return 1 if $config->exists('disable');
    return;
}

sub is_same_as_file {
    my ($file, $value) = @_;

    return if ! -e $file;

    my $mem_file = '';
    open my $MF, '+<', \$mem_file or die "couldn't open memfile $!\n";
    print $MF $value;
    seek($MF, 0, 0);
    
    my $rc = compare($file, $MF);
    return 1 if $rc == 0;
    return;
}

sub write_conf_file {
    my ($file, $config) = @_;

    # Avoid unnecessary writes.  At boot the file will be the
    # regenerated with the same content.
    return if is_same_as_file($file, $config);

    open(my $fh, '>', $file) || die "Couldn't open $file - $!";
    print $fh $config;
    close $fh;
    return 1;
}

sub validate_config {
    my $config = new Vyatta::Config;

    my $path = 'protocols igmp-proxy interface';
    $config->setLevel($path);

    my @interfaces = $config->listNodes();
    if (scalar(@interfaces) < 2) {
        print "Error: must define an upstream and at least 1 downstream\n";
        exit 1;
    }
    my $upstream = 0;
    foreach my $intf (@interfaces) {
        $config->setLevel("$path $intf");
        my $role = $config->returnValue('role');
        $upstream++ if $role eq 'upstream';
    }
    if ($upstream > 1) {
        print "Error: only 1 upstream interface allowed\n";
        exit 1;
    }
    if ($upstream < 1) {
        print "Error: must define an upsteam interface\n";
        exit 1;
    }
}

sub get_config_static {
    my $output = '';

    $output .= "#\n# autogenerated by $0\n#\n";
    $output .= "\n";

}
sub get_config {
    
    my $config = new Vyatta::Config;
    my $output = get_config_static();

    my $path = 'protocols igmp-proxy';
    $config->setLevel($path);
    if ($config->exists('disable-quickleave')) {
        $output .= "#quickleave\n\n"
    } else {
        $output .= "quickleave\n\n"
    }

    my @interfaces = $config->listNodes('interface');
    foreach my $intf (@interfaces) {
        $config->setLevel("$path interface $intf");
        my $role      = $config->returnValue('role');
        my $threshold = $config->returnValue('threshold');
        my @alts      = $config->returnValues('alt-subnet');
        my @whites    = $config->returnValues('whitelist');

        $output .= "phyint $intf $role ratelimit 0 threshold $threshold\n";
        foreach my $alt (@alts) {
            $output .= "\taltnet $alt\n";
        }
        foreach my $white (@whites) {
            $output .= "\twhitelist $white\n";
        }
        $output .= "\n";
    }

    return $output;
}

sub enable_igmpproxy {

    if (is_disabled()) {
        if (is_running($pidfile)) {
            disable_igmpproxy();
        }
        exit 0;
    }

    validate_config();
    my $output = get_config();
    write_conf_file($conffile, $output);

    my ($cmd, $rc) = ('', '');
    if (is_running($pidfile)) {
        disable_igmpproxy();
    }
    $cmd  = "/sbin/start-stop-daemon --start --startas $daemon --make-pidfile ";
    $cmd .= "--pidfile $pidfile --background -- $conffile";
    $rc = system($cmd);

    return $rc;
}

sub disable_igmpproxy {
    my ($intf) = @_;

    if (! is_running($pidfile)) {
        print "Warning: igmpproxy not running.\n";
        exit 0;
    }

    my ($cmd, $rc) = ('', '');
    $cmd  = "/sbin/start-stop-daemon --stop --pidfile $pidfile";
    $rc = system($cmd);

    return $rc;
}


#
# main
#

my ($action);

GetOptions("action=s"    => \$action,
) or usage();

die "Must define action\n" if ! defined $action;

my $rc = 1;
$rc =  enable_igmpproxy()  if $action eq 'enable';
$rc =  disable_igmpproxy() if $action eq 'disable';

exit $rc;

# end of file
